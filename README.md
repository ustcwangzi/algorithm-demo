# algorithm-demo
## sort 排序
- Insertion：插入排序
- Selection：选择排序
- Shell：希尔排序
- Quick：快速排序
- Merge：归并排序
- Heap：堆排序
- LSD：低位优先排序
- MSD：高位优先排序
- QuickThreeWay：三向快速排序

## search 查找
- SequentialSearch：顺序查找
- BinarySearch：二分查找
- BinarySearchTree：二叉查找树
- SeparateChainingHashSearch：基于链表的散列表查找
- LinearProbingHashSearch：基于线性探测的散列表查找
### str 字符串查找
- TrieSearchTree：R向单词查找树
- ThreeWaySearchTree：三向单词查找树
- KMP：KMP字符串查找算法
- RabinKarp：RabinKarp指纹字符串查找算法
- RegExpSearch：正则表达式匹配

## unionfind 动态连通性
- UnionFind：普通UnionFind算法
- QuickUnionFind：快速UnionFind算法
- WeightedQuickUnionFind：加权快速UnionFind算法

## graph 图
### undirected 无向图
- Graph：使用邻接表表示图
- DepthFirstSearch：深度优先遍历
- DepthFirstPaths：使用深度优先遍历查找路径
- ConnectedComponent：计算联通分量
- BreadthFirstPaths：广度优先遍历查找路径
### directed 有向图
- Digraph：使用邻接表表示有向图
- DepthFirstOrder：基于深度优先搜索的顶点排序
- DepthFirstDirectedPaths：使用深度优先搜索查找有向图中的路径
- BreadthFirstDirectedPaths：使用广度优先搜索查找有向图中的路径
- DirectedCycle：寻找有向环
- DirectedDFS：深度优先遍历计算有向图的可达性
- KosarajuConnectedComponent：计算强联通分量
- Topological：拓扑排序
- TransitiveClosure：顶点对的可达性
### mst 最小生成树(Minimum Spanning Tree)
- WeightedGraph：加权无向图
- LazyPrimMST：Prim算法延时实现
- PrimMST：Prim算法即时实现
- KruskalMST：Kruskal算法
### shortestpath 最短路径(Shortest Path)
- WeightedDigraph：加权有向图
- DijkstraSP：Dijkstra算法
- BellmanFordSP：BellmanFord算法
### flow 流量
- FordFulkerson：Ford-Fulkerson最大流量算法

## grokking 算法图解
- BinarySearch：二分查找
- SelectionSort：选择排序
- QuickSort：快速排序
- BreadthFirstSearch：广度优先搜索
- DijkstraAlgorithm：Dijkstra算法
- SetCoverage：贪婪算法解决集合覆盖
- LongestCommonSubsequence：最长公共子序列

## daily 随手
- BubbleSort：冒泡排序

## stackandqueue 栈和队列
- GetMinStack：有getMin()功能的栈
- TwoStacksImplementQueue：两个栈实现队列
- ReverseStackUsingRecursive：使用递归将栈逆置
- DogCatQueue：猫狗队列
- StackSortStack：用一个栈实现另一个栈的排序
- HanoiStack：汉诺塔问题
- SlidingWindowMaxArray：生成窗口最大值数组
- MaxTree：构造数组的MaxTree
- MaxRectangle：最大子矩阵
- AllLessNumSubArray：最大最小值之差小于等于num的子数组数量
